<!DOCTYPE html>
<html>
<head>
  <title>FRC Match Strategy Planner</title>
  <style>
   body {
    font-family: 'Arial', sans-serif;
    margin: 0;
    padding: 20px;
    background-color: #ffffff;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  

  .controls {
  display: flex;
  flex-direction: column; /* Stack controls vertically */
  align-items: center; /* Align controls in the middle */
  width: 100%; /* Use full width to manage spacing better */
  gap: 15px; /* Space out the individual controls */
}

  select, button, input {
    padding: 10px;
    margin-right: 5px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 5px;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    transition: border-color 0.3s;
  }

  button {
    background-color: #4CAF50;
    color: white;
    cursor: pointer;
    border: none;
  }

  button:hover {
    background-color: #45a049;
  }
  #backgroundImage {
    /* background-image: url('https://www.chiefdelphi.com/uploads/default/original/3X/a/a/aa745548020a507cf4a07051dcd0faa446607840.png'); */
  }

  #autoCanvas {
      width: 100%;
      /* background-image: url('https://www.chiefdelphi.com/uploads/default/original/3X/a/a/aa745548020a507cf4a07051dcd0faa446607840.png'); */
      background-image: url("images/crescendo_feild.png");
      background-size: contain;
      border: 1px solid #000;
      width: 1152; /* Adjust based on your actual need */
      height: 498; /* Adjust based on your actual need */
    }

    #teleopCanvas {
      width: 100%;
      /* background-image: url('https://www.chiefdelphi.com/uploads/default/original/3X/a/a/aa745548020a507cf4a07051dcd0faa446607840.png'); */
      background-image: url("images/crescendo_feild.png");
      background-size: contain;
      border: 1px solid #000;
      width: 1152; /* Adjust based on your actual need */
      height: 498; /* Adjust based on your actual need */
    }

  select:focus, button:focus, input:focus {
    border-color: #4CAF50;
    outline: none;
  }

  #eventCodeInput {
    flex-grow: 1;
    background-color: #ae83e3;
    padding: 10px;
    border-radius: 8px;
  }

  #newOptionContainer {
    margin-bottom: 20px;
    background-color: #ffffff;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }
  
  #button-container {
  display: flex;
  justify-content: space-around; /* Space out buttons evenly */
  flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
  gap: 20px; /* Space between buttons when they wrap */
  width: 80%; /* Adjust based on your layout needs */
  margin-top: 10px; /* Add some space above the button container */
}

#button-container button {
  flex: 1; /* Allow buttons to grow and fill the space */
  margin: 0 5px; /* Add margin on the sides */
  min-width: 180px; /* Minimum width for buttons to maintain readability */
}

#other-button-container {
  display: flex;
  justify-content: space-around; /* Space out buttons evenly */
  flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
  gap: 50px; /* Space between buttons when they wrap */
  width: 80%; /* Adjust based on your layout needs */
  margin-top: 10px; /* Add some space above the button container */
}

#manualTeamEntry div {
  display: flex;
  justify-content: center;
  gap: 10px; /* Space between input fields */
}

#manualTeamEntry {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px; /* Space between rows */
}

#switchTabs {
  background-color: hsl(206, 100%, 61%);
  /* background-color: #ff6161; */
}

#clear {
   background-color: #ff6161;
}

#matchSelect-label {
  font-size: 30px;
  font-weight: 600;
}

#matchSelect-container {
  display: flex;
  justify-content: space-around; /* Space out buttons evenly */
  flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
  gap: 10px; /* Space between buttons when they wrap */
  width: 15%; /* Adjust based on your layout needs */
  margin-top: 10px; /* Add some space above the button container */
  padding: 20px;
  border-radius: 8px;
  background-color: #8595ff;
}

  .eventAndDirections {
    display: flex;
  }

  nav {
    background-color: #1df700;
    width: 1000px;
    text-align: center;
    padding: 10px 0;
    border-radius: 10px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    justify-content: center;
    flex-wrap: wrap; /* Ensures nav items wrap in smaller screens */
  }

  nav a {
    text-decoration: none;
    color: #000000;
    margin: 0 10px;
    font-weight: bold;
    font-size: 20px;
    padding: 10px;
    background-color: #1df700; /* Makes sure each link has a green background */
    border-radius: 8px;
  }

  nav a:hover {
    background-color: #3295ff;
  }

  .button {
  display: inline-block;
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
  text-align: center;
  text-decoration: none;
  outline: none;
  color: #fff;
  background-color: #4CAF50;
  border: none;
  border-radius: 5px;
  /* box-shadow: 0 9px #999; */
}

.button:hover {background-color: #45a049}

.button:active {
  background-color: #3e8e41;
  /* box-shadow: 0 5px #666; */
  /* transform: translateY(4px); */
}

/* Additional styling for file input to make it invisible */
#uploadMatchData {
  display: none;
}

/* Media Query for screens with a max-width of 600px */
@media (max-width: 600px) {
    nav {
      flex-direction: column;
    }

    nav a {
      width: 100%; /* Ensures each link uses the full width of nav */
      margin: 5px 0; /* Adjusts spacing between links in the vertical layout */
      padding: 0;
    }
  }

    /* Adjust the .controls container to stack its children vertically */
    .controls {
      flex-direction: column;
      align-items: center; /* Align items for a centered layout */
    }
  </style>
</head>
<body>

  <nav>
    <a href="./index.html">Home</a>
        <a href="./Team_List_element.html">Teams</a>
        <a href="./Strat_Board_w_tabs.html">Canvas</a>
        <a href="./Checklist.html">Pre Match Checklist</a>
        <a href="./2423_Features.html">Features</a>
        <a href="./Config_tab.html">Configure</a>
  </nav>


<div class="controls">

  <h2>Current Event Code From Config: <span id="eventCodeInput"></span></h2>

  <!-- <select id="eventCodeInput">
    <option value="2024mabos">2024 Greater Boston Event</option>
    <option value="2024mabri">2024 Week 2 BSU Event</option>
    <option value="2024week0">2024 Week 0 Event</option>
</select>
<button onclick="fetchMatches()">Load Matches</button>
</div>

<div id="newOptionContainer">
  <input type="text" id="newOptionText" placeholder="Type new option here"/>
      <button id="addOptionButton">Add Option</button>
</div> -->

<div id="matchSelect-container">
<label id="matchSelect-label">Select a match</label>
<select id="matchSelect"></select>
</div>

<div id="other-button-container">
  
  <button id="saveCanvas">Save Autonomous Canvas as PNG</button>
  
  <input type="file" id="uploadMatchData" style="display: none;" />
  <label for="uploadMatchData" class="button">Upload Match Data</label>
  
  
  <input type="file" id="fileInput" style="display: none;"/>
  <button id="toggleDataInputMode">Switch to Manual Team Entry</button>
  <div id="manualTeamEntry" style="display: none;">
    <div>
      <input type="text" id="blue1" placeholder="Blue Team 1">
      <input type="text" id="blue2" placeholder="Blue Team 2">
      <input type="text" id="blue3" placeholder="Blue Team 3">
    </div>
    <div>
      <input type="text" id="red1" placeholder="Red Team 1">
      <input type="text" id="red2" placeholder="Red Team 2">
      <input type="text" id="red3" placeholder="Red Team 3">
    </div>
    <button id="submitManualTeams">Submit Teams</button>
  </div>
  
</div>

<div id="button-container">
  <button id="clear"onclick="clearCanvas()">Clear</button>
  <button id="toggleEraser">Toggle Eraser</button>
  <button onclick="switchTabs()"id="switchTabs">Switch Tabs</button>
  
</div>

<!-- <input type="text" id="eventCodeInput" placeholder="Enter Event Code" value="2024mabri"/> -->

<h1 id="tabLabel">Autonomous</h1>
<div id="backgroundImage">
  <canvas id="autoCanvas" width="1536" height="664" style="display: show;"></canvas>
  <canvas id="teleopCanvas" width="1536" height="664" style="display: none;"></canvas>
</div>






<script>


  // import saveCanvas from "save-canvas-to-image";
  
  let isManualEntry = false;
  let apiData = [];
  
  let eraserEnabled = false;

  let selectedMatchKey = "";
  let eventCode = '';

//   document.getElementById('saveAutoCanvas').addEventListener('click', function() {
//     const canvas = document.getElementById('teleopCanvas');
//     const dataURL = canvas.toDataURL('image/png');
//     const link = document.createElement('a');
//     link.download = `autonomous-${selectedMatchKey}-canvas.png`;
//     link.href = dataURL;
//     link.click();
// });

// document.getElementById('saveAutoCanvas').addEventListener('click', function() {
//     // Assume canvas size is constant, and we want to preserve it
//     const canvas = document.getElementById('teleopCanvas');
//     const ctx = canvas.getContext('2d');
    
//     // Background Image
//     const backgroundImage = new Image();
//     backgroundImage.src = "images/crescendo_feild.png"; // Ensure this path is correct

//     backgroundImage.onload = () => {
//         // Create a temporary canvas to draw the background and the existing content
//         const tempCanvas = document.createElement('canvas');
//         const tempCtx = tempCanvas.getContext('2d');

//         tempCanvas.width = canvas.width;
//         tempCanvas.height = canvas.height;

//         // Draw the background on the temp canvas, scaled to fit
//         tempCtx.drawImage(backgroundImage, 0, 0, tempCanvas.width, tempCanvas.height);

//         // Now draw the original canvas content on top of the background
//         tempCtx.drawImage(canvas, 0, 0);

//         // Save the combined content from the temporary canvas
//         const dataURL = tempCanvas.toDataURL('image/png');
//         const link = document.createElement('a');
//         link.download = `autonomous-${selectedMatchKey}-canvas.png`; // You can change the filename
//         link.href = dataURL;
//         link.click();
//     };
// });

document.getElementById('toggleDataInputMode').addEventListener('click', function() {
  isManualEntry = !isManualEntry;
  document.getElementById('manualTeamEntry').style.display = isManualEntry ? "block" : "none";
  document.getElementById('matchSelect').style.display = isManualEntry ? "none" : "block";
  document.getElementById('matchSelect-container').style.display = isManualEntry ? "none" : "flex";
  this.textContent = isManualEntry ? "Switch to API Data Entry" : "Switch to Manual Team Entry";
});

document.getElementById('submitManualTeams').addEventListener('click', function() {
  const blueTeams = [
    document.getElementById('blue1').value,
    document.getElementById('blue2').value,
    document.getElementById('blue3').value
  ];
  const redTeams = [
    document.getElementById('red1').value,
    document.getElementById('red2').value,
    document.getElementById('red3').value
  ];
  
  // Validate input (basic example, extend as needed)
  if (blueTeams.some(team => team === "") || redTeams.some(team => team === "")) {
    alert("Please fill in all team numbers.");
    return;
  }
  
  // Assuming drawTeams function can handle team numbers directly
  clearCanvas();
  drawTeams(blueTeams.map(team => `frc${team}`), bluePositions, 'blue');
  drawTeams(redTeams.map(team => `frc${team}`), redPositions, 'red');
});



document.addEventListener('DOMContentLoaded', function() {
  updateSaveButton();
    const uploadButton = document.getElementById('uploadMatchData');
    const fileInput = document.getElementById('uploadMatchData');

    uploadButton.addEventListener('click', function() {
      fileInput.click(); // Trigger file input when upload button is clicked
    });

    fileInput.addEventListener('change', function(event) {
      uploadData(event); // Call your existing function to handle file upload
    });

  }

  
  
  ); 
  document.getElementById('saveCanvas').addEventListener('click', function() {
  const canvas = isAuto ? document.getElementById('autoCanvas') : document.getElementById('teleopCanvas');
  const ctx = canvas.getContext('2d');
  const backgroundImage = new Image();
  const fileName = `${isAuto ? 'autonomous' : 'teleop'}-${selectedMatchKey}-canvas.png`; // Adjust file name based on the canvas type
  backgroundImage.src = "images/crescendo_feild.png";
  backgroundImage.onload = () => {
        // Create a temporary canvas to draw the background and the existing content
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;

        // Draw the background on the temp canvas, scaled to fit
        tempCtx.drawImage(backgroundImage, 0, 0, tempCanvas.width, tempCanvas.height);

        // Now draw the original canvas content on top of the background
        tempCtx.drawImage(canvas, 0, 0);

        // Save the combined content from the temporary canvas
        const dataURL = tempCanvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = `${fileName}-${selectedMatchKey}-canvas.png`; // You can change the filename
        link.href = dataURL;
        link.click();
    };
});


  function uploadData(event) {
  // apiData = [];
  const file = event.target.files[0];
  if (!file) {
    return;
  }
  const reader = new FileReader();
  reader.onload = (e) => {
    clearPreviousData(); // Make sure this function fully resets the state as needed
    const content = e.target.result;
    try {
      apiData = JSON.parse(content);
      populateMatchSelect(apiData); // This should trigger a UI update to reflect the new data
      // Optionally, clear and reset the canvas or other UI elements as needed here
    } catch (err) {
      console.error('Failed to parse uploaded file:', err);
    }
  };
  reader.readAsText(file);
}

  // document.getElementById('addOptionButton').addEventListener('click', function() {
  //       const selectElement = document.getElementById('eventCodeInput');
  //       const newOptionText = document.getElementById('newOptionText').value;
  //       if (newOptionText.trim() !== '') { // Ensure the input is not empty or just whitespace
  //           const newOptionElement = new Option(newOptionText, newOptionText.toLowerCase().replace(/\s+/g, '_'));
  //           selectElement.add(newOptionElement);
  //           document.getElementById('newOptionText').value = ''; // Clear the input field after adding
  //       }
  //   });



document.getElementById('toggleEraser').addEventListener('click', function() {
  eraserEnabled = !eraserEnabled;
  if (isAuto) {
        ctx = ctxAuto;
        canvas = canvasAuto
      } else {
        ctx = ctxTeleop
        canvas = canvasTeleop
      }
  if (eraserEnabled) {
    // Activate eraser mode
    ctx.globalCompositeOperation = 'destination-out';
    this.textContent = 'Switch to Pen'; // Change the button text accordingly
  } else {
    // Back to drawing mode
    ctx.globalCompositeOperation = 'source-over';
    this.textContent = 'Toggle Eraser';
  }
});
  window.addEventListener("load", onPageLoad)
    const canvasAuto = document.getElementById('autoCanvas');
    const canvasTeleop = document.getElementById('teleopCanvas');
    const ctxAuto = canvasAuto.getContext('2d');
    const ctxTeleop = canvasTeleop.getContext('2d');
    const tabLabel = document.getElementById('tabLabel')
    const matchSelect = document.getElementById('matchSelect');
    let matches = [];
    let drawing = false;
    let drawColor = 'black';
    let teamPositions = [];
  
    const bluePositions = [{x: 70, y: 150}, {x: 70, y: 380}, {x: 70, y: 500}];
    const redPositions = [{x: 1400, y: 500}, {x: 1400, y: 380}, {x: 1400, y: 150}];
    const teamColors = {
      blue: ['#07f7df', '#075bf7', '#AD00FF'],
      red: ['#FF00A5', '#f76707', '#f7c707']
    };
  
    setupCanvas();


    function onPageLoad() {
      let isAuto = true;
        switchTabs();
    }

    function switchTabs() {
  if (canvasAuto.style.display !== "none") {
    canvasTeleop.style.display = "block";
    canvasAuto.style.display = "none";
    isAuto = false; // Update to reflect the current canvas
    tabLabel.textContent = "Teleop";
  } else {
    canvasTeleop.style.display = "none";
    canvasAuto.style.display = "block";
    isAuto = true; // Update to reflect the current canvas
    tabLabel.textContent = "Autonomous";
  }
  updateSaveButton(); // Update the save button's label and functionality
}

function updateSaveButton() {
  const saveButton = document.getElementById('saveCanvas');
  if (isAuto) {
    saveButton.textContent = 'Save Autonomous Canvas as PNG';
  } else {
    saveButton.textContent = 'Save Teleop Canvas as PNG';
  }
}


    function setupCanvas() {
      // Mouse Events
      canvasAuto.addEventListener('mousedown', startDrawing);
      canvasAuto.addEventListener('mouseup', stopDrawing);
      canvasAuto.addEventListener('mouseout', stopDrawing);
      canvasAuto.addEventListener('mousemove', drawMouse);

      // Touch Events
      canvasAuto.addEventListener('touchstart', startDrawingTouch, false);
      canvasAuto.addEventListener('touchend', stopDrawingTouch, false);
      canvasAuto.addEventListener('touchcancel', stopDrawingTouch, false);
      canvasAuto.addEventListener('touchmove', drawTouch, false);

      canvasTeleop.addEventListener('mousedown', startDrawing);
      canvasTeleop.addEventListener('mouseup', stopDrawing);
      canvasTeleop.addEventListener('mouseout', stopDrawing);
      canvasTeleop.addEventListener('mousemove', drawMouse);

      // Touch Events
      canvasTeleop.addEventListener('touchstart', startDrawingTouch, false);
      canvasTeleop.addEventListener('touchend', stopDrawingTouch, false);
      canvasTeleop.addEventListener('touchcancel', stopDrawingTouch, false);
      canvasTeleop.addEventListener('touchmove', drawTouch, false);
    }
  
    function startDrawing(e) {
      if (isAuto){
        canvas = canvasAuto;
      } else {
        canvs = canvasTeleop;
      }
      drawing = true;
      var offsetX = e.offsetX || e.touches[0].clientX - canvas.getBoundingClientRect().left;
      var offsetY = e.offsetY || e.touches[0].clientY - canvas.getBoundingClientRect().top;
      checkTeamClick(offsetX, offsetY);
      // Prevents the mouse down from having an additional side effect, such as starting a selection
      e.preventDefault();
    }

    function stopDrawing() {
      if (drawing) {
        drawing = false;
      }
      if (isAuto) {
        ctxAuto.beginPath();
      } else {
        ctxTeleop.beginPath();
      }
    }

    function drawMouse(e) {
      if (drawing) {
        var offsetX = e.offsetX;
        var offsetY = e.offsetY;
        draw(offsetX, offsetY);
      }
    }

     function startDrawingTouch(e) {
      if (e.touches.length == 1) { // Only track one finger
        startDrawing(e);
      }
    }

    function drawTouch(e) {
      if (isAuto) {
        if (drawing) {
        var touch = e.touches[0];
        var offsetX = touch.clientX - canvasAuto.getBoundingClientRect().left;
        var offsetY = touch.clientY - canvasAuto.getBoundingClientRect().top;
        draw(offsetX, offsetY);
      }
      } else {
        if (drawing) {
          var touch = e.touches[0];
          var offsetX = touch.clientX - canvasTeleop.getBoundingClientRect().left;
          var offsetY = touch.clientY - canvasTeleop.getBoundingClientRect().top;
          draw(offsetX, offsetY);
        }
      }
      e.preventDefault(); // Prevent scrolling when touching the canvas
    }

    function stopDrawingTouch() {
      stopDrawing();
    }

    function draw(x, y) {
      if (isAuto) {
        ctx = ctxAuto;
        canvas = canvasAuto
      } else {
        ctx = ctxTeleop
        canvas = canvasTeleop
      }
  // Adjust drawing logic to support erasing
  ctx.lineWidth = eraserEnabled ? 50 : 4; // You might want a larger lineWidth for erasing
  ctx.lineCap = 'round';
  ctx.strokeStyle = eraserEnabled ? 'rgba(0,0,0,1)' : drawColor; // Use the background color or fully opaque color for erasing

  const scale = 1536 / canvas.clientWidth;
      const scaleX = scale * x;
      const scaleY = scale * y;
      ctx.lineTo(scaleX, scaleY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(scaleX, scaleY);

  
}
  
  
    function fetchMatches() {
      const eventCode = localStorage.getItem('eventCode');
      document.getElementById('eventCodeInput').textContent = eventCode;
      console.log(eventCode)
      const webhookEndpoint = `https://www.thebluealliance.com/api/v3/event/${eventCode}/matches/simple`;
      fetch(webhookEndpoint, {
        method: "GET",
        headers: {
          "X-TBA-Auth-Key": "J43Af3iggAp3XBvsVaGm5Hbc7IlK6XR8W8WxQhLDlPiQbv6BbW8LWDvVg8Zj9fCV",
        },
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Invalid Event Code');
        }
        return response.json();
      })
      .then(data => {
        matches = data;
        apiData = data;
        populateMatchSelect(data);
      })
      .catch(error => console.error('Error fetching matches:', error));
    }
  
    function populateMatchSelect(matches) {
      matchSelect.innerHTML = '';
      
      // Sort matches by their match number
      matches.sort((a, b) => {
        let compLevelA = a.comp_level + a.set_number.toString().padStart(3, '0') + a.match_number.toString().padStart(3, '0');
        let compLevelB = b.comp_level + b.set_number.toString().padStart(3, '0') + b.match_number.toString().padStart(3, '0');
        return compLevelA.localeCompare(compLevelB);
      });

      matches.forEach(match => {
        const option = document.createElement('option');
        option.value = match.key;
        option.textContent = `${match.comp_level.toUpperCase()} Match ${match.match_number}`;
        matchSelect.appendChild(option);
      });
    }
  
    function displayTeamsForSelectedMatch() {
      selectedMatchKey = matchSelect.value;
      const selectedMatch = apiData.find(match => match.key === selectedMatchKey);
      const match = apiData.find(m => m.key === selectedMatchKey);
      console.log(match)
      if (!match) {
        return;
      }
      if (!selectedMatch) {
    console.error('Selected match not found');
    return;
  }

      clearCanvas();
      console.log("cleared canvas")
      teamPositions = []; // Reset team positions
  
      drawTeams(match.alliances.blue.team_keys, bluePositions, 'blue');
      drawTeams(match.alliances.red.team_keys, redPositions, 'red');
    }

    const uploadInput = document.getElementById('uploadMatchData');
      uploadInput.addEventListener('change', uploadData);

    

    function clearPreviousData() {
    // Clear the global data variable
    apiData = [];
    }
  
    function drawTeams(teamKeys, positions, alliance) {
      if (isAuto) {
        ctx = ctxAuto
      } else {
        ctx = ctxTeleop
      }
  ctx.font = '40px Arial'; // Ensure font size is set before measuring text
  const padding = 10; // Padding around the text for the outline box

  teamKeys.forEach((key, index) => {
    clearCanvas()
    const teamNumber = key.replace('frc', '');
    const position = positions[index];
    const color = teamColors[alliance][index];

    const textMetrics = ctx.measureText(teamNumber);
    const textWidth = textMetrics.width;
    const rectHeight = 50; // Example height of clickable area
    const rectY = position.y - 40; // Adjust based on font size and desired box size

    // Draw the team number and background
    ctx.fillStyle = color;
    ctx.fillRect(position.x - (padding / 2), rectY, textWidth + padding, rectHeight);
    ctx.fillStyle = 'black';
    ctx.fillText(teamNumber, position.x, position.y);

    // Store positions for click detection
    teamPositions.push({
      x: position.x - (padding / 2),
      y: rectY,
      width: textWidth + padding, 
      height: rectHeight,
      color: color,
      text: teamNumber
    });
  });
}

  
    function drawText(text, x, y, color, index, alliance) {
      if (isAuto) {
        ctx = ctxAuto
      } else {
        ctx = ctxTeleop
      }
    // Calculate text width for background and click detection area
    ctx.font = '40px Arial'; // Ensure font size is set before measuring text
    const textMetrics = ctx.measureText(text);
    const textWidth = textMetrics.width;
    const padding = 10; // Padding around the text for the outline box

    // Adjust position for the rectangle to be centered on the text if necessary
    const rectX = x - padding / 2;
    const rectY = y - 40; // Adjust based on font size and desired box size
    const rectWidth = textWidth + padding;
    const rectHeight = 50;

    // Draw the colored background rectangle
    ctx.fillStyle = color;
    ctx.fillRect(rectX, rectY, rectWidth, rectHeight);

    // Draw the team number text on top
    ctx.fillStyle = 'black'; // Contrast color for text
    ctx.fillText(text, x, y);
  
    document.getElementById('tabLabel').style.backgroundColor = "blue"

    // Update the teamPositions array for click detection
    teamPositions.push({
      x: rectX,
      y: rectY,
      width: rectWidth,
      height: rectHeight,
      color: color, // Assign the drawing color for when the area is clicked
    });
  }

  function checkTeamClick(x, y) {
    let scale, scaledX, scaledY, colorFound = false;

    if (isAuto) {
        ctx = ctxAuto;
        canvas = canvasAuto;
    } else {
        ctx = ctxTeleop;
        canvas = canvasTeleop;
    }

    if (!eraserEnabled) {
        teamPositions.forEach(team => {
            // Convert canvas-relative coordinates to the scaled drawing coordinates
            scale = canvas.offsetWidth / canvas.width;
            scaledX = x / scale;
            scaledY = y / scale;

            // Check if the click is within the bounds of a team's clickable area
            if (scaledX >= team.x && scaledX <= (team.x + team.width) && scaledY >= team.y && scaledY <= (team.y + team.height)) {
                drawColor = team.color; // Set the drawing color to the team's color
                colorFound = true; // Indicate that a color was found based on user click
                console.log("Selected color:", team.color); // Logging for verification
            }
        });

        // If a team's color was found, update the tabLabel's background color
        if (colorFound) {
            // document.getElementById('tabLabel').style.backgroundColor = drawColor;
            canvas.style.border = "20px solid " + drawColor;
            canvas.style.borderRadius = "10px";
        }
    }
}


  
function clearCanvas() {
  
  if (isAuto) {
    ctx = ctxAuto
    canvas = canvasAuto
  } else {
    ctx = ctxTeleop
    canvas = canvasTeleop
  }
  ctx.clearRect(0, 0, canvas.width, canvas.height);
   ctx.globalCompositeOperation = 'source-over';
  // After clearing, redraw the team number boxes
  teamPositions.forEach(team => {
    drawTeamNumberBox(team.x, team.y, team.width, team.height, team.color, team.text);
  });
}

function drawTeamNumberBox(x, y, width, height, color, text) {
  ctx.fillStyle = color;
  // Draw rectangle for team number background
  ctx.fillRect(x, y, width, height);
  ctx.fillStyle = 'black'; // Assuming text color is always black
  // Adjustments for text positioning within the rectangle if needed
  ctx.font = '40px Arial'; // Ensure this matches the initial drawing's font
  // Calculate the y position to vertically center the text in the rectangle
  const textY = y + height / 2 + ctx.measureText(text).actualBoundingBoxAscent / 2;
  ctx.fillText(text, x + (width / 2) - (ctx.measureText(text).width / 2), textY); // Center the text inside the rectangle
}

  
    matchSelect.addEventListener('change', displayTeamsForSelectedMatch);
    fetchMatches();
  </script>  
</body>
</html>